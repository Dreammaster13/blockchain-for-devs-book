# Exercises: Using Web3.js to Access Ethereum Smart Contracts from JavaScript through Infura

**Web3.js** is a collection of libraries, which allow you to interact
with a local or remote Ethereum node, using a HTTP or IPC connection. In
this exercise, we will use **web3.js** to deploy a contract on the
Ethereum Ropsten Testnet and play with it. We will first compile a
contract, deploy it and finally call some of the contract's functions.
In order to web3 connect to the Ropsten Testnet, we will use Infura.io
API as a provider.

Infura.io API
-------------

To start with, **create** a new project at an appropriate place. In the
directory, **open** a terminal and initialize **package.json** file:

  --------------
  npm init --y
  --------------

After that, install **solc-js**:

  ---------------------------
  npm install ----save solc
  ---------------------------

Because we will read a smart contract from a file, we will need a
file-system library:

  -------------------------------
  npm install ----save fs-extra
  -------------------------------

Last but not least, **web3.js**:

  ---------------------------
  npm install ----save web3
  ---------------------------

Now let's get the necessary Infura.io provider. **Go** to
<https://infura.io/> and click **\[Get started for free\]**:

![](/assets/exercises-smart-contracts-web3-and-infura-01.png)

Fill out the form and click **\[Submit\]**. Then **copy** the Ropsten
URL:

![](/assets/exercises-smart-contracts-web3-and-infura-012.png)

After we have installed our dependencies, create a JavaScript file, set
them up as global variables in the beginning of the file. Then, paste
the **Infura** **URL** as a provider. A **provider** abstracts a
connection to the Ethereum blockchain for issuing queries and sending
state changing transactions. It is simply a connection to the network.

Then initialize **web3** with the given provider:

![](/assets/exercises-smart-contracts-web3-and-infura-018.png)

Compiling a Smart Contract
--------------------------

The Smart Contract object is a meta-class, so many of the functions in
it are not defined until it is instantiated with an application binary
interface (ABI) which is usually generated by a compiler, such as
Solidity. Therefore, we will use **solc-js** library -- JavaScript
bindings for the Solidity compiler.

Now, we will create a simple smart contract, which will store a string
array of facts in the blockchain. **Only** the **owner** of the contract
can **add** facts, but anyone can get how many **facts** are there and
get a fact by **index**.

![](/assets/exercises-smart-contracts-web3-and-infura-019.png)

Now that we have written the smart contract, we will create a function
in our JavaScript file, which reads a file and returns its content:

![](/assets/exercises-smart-contracts-web3-and-infura-020.png)

Let's compile the file now. We will create a function called
**compileContract**, which takes the name of the file and name of the
contract and returns an output of the compiled contract:

![](/assets/exercises-smart-contracts-web3-and-infura-022.png)

Deploy a Smart Contract
-----------------------

Now that we have compiled our Smart Contract for facts, it is time to
**deploy** it on the Ropsten Testnet. For the example of the exercise,
we will take one private key from MetaMask and use it as a signer for
the deployment transaction.

![](/assets/exercises-smart-contracts-web3-and-infura-023.png)

If you do not have ETHt, use the **MetaMask** faucet:
<https://faucet.metamask.io/>

![](/assets/exercises-smart-contracts-web3-and-infura-024.png)

Export the private key:

![](/assets/exercises-smart-contracts-web3-and-infura-03.png)

First, we will create a **deployContract** function, which takes a
Private Key, contract filename and the contract's name.

To deploy a contract to the Ethereum Network, we must have its bytecode
and its application binary interface (ABI), usually generated from the
Solidity compile.

We will add in **web3's accounts** the private key. Then, compile the
contract. After that, we will use **web3.eth.Contract (jsonInterface \[,
address\] \[, options\])**, which will create a new contract with all
its methods defined in its json interface object. Since we have no
address to deploy it to, we will leave it null and add as additional
options: **data** -- the **bytecode** of the contract, **gas** -- the
maximum gas provided for a transaction (gas limit) and **from** -- the
address from which the transaction should be made. Then call the
contract's **deploy** function, which after successful deployment the
promise resolves with a new contract instance and sends the transaction.
After the transaction is mined, as a callback result of the contract
instance, we will print the contract address:

![](/assets/exercises-smart-contracts-web3-and-infura-06.png)

Playing with the Smart Contract
-------------------------------

Now that the Smart Contract is deployed, we will connect to a Smart
Contract using **web3** to add facts to our contract. For ease, copy the
address and abi of the contract and set them into two variables:

![](/assets/exercises-smart-contracts-web3-and-infura-07.png)

Create a method called **addFact**, which takes the Contract Address, an
ABI of the contract, a Private Key for the wallet and the fact. The
method will return a callback of the created transaction. Keep in mind
the transaction information will return once the transaction is mined.

![](/assets/exercises-smart-contracts-web3-and-infura-09.png)

The **status** shows whether the transaction was successful or not.

In Etherscan:

![](/assets/exercises-smart-contracts-web3-and-infura-010.png)

What will happen if the **someone**, **different** from contract owner,
tries to add a fact to the contract? Get another address, which has any
ETHt, and execute the method with its private key.

![](/assets/exercises-smart-contracts-web3-and-infura-013.png)

Now, let's create a method, which calls the contract's function
**getFact** (uint256 index). Keep in mind that when you want to **GET**
something from a contract, you **do not need** a wallet! Therefore, only
the **ABI**, contract address and index are needed.

![](/assets/exercises-smart-contracts-web3-and-infura-015.png)

Last but not least, a function calling the **count()** of the contract,
which returns the count of the facts in the contract:

![](/assets/exercises-smart-contracts-web3-and-infura-017.png)

What to Submit?
===============

Create a **zip file** (e.g.
**username-playing-smart-contracts-web3-js.zip**) holding the JavaScript
file with the methods, a snapshot of the Ropsten Etherscan contract
address and its transactions.

Submit your **zip** file as **homework** at the course Website.
