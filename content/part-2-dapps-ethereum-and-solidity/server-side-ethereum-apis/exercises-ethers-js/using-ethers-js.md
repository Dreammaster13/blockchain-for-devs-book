# Exercises: Using Ethers.js to Access Ethereum Smart Contracts from JavaScript

In this exercise, we will use **ethers.js** library to create a
connection to a contract, deployed on the Ethereum Ropsten Testnet. We
will first compile a contract, deploy it and finally call some of the
contract's functions.

Compiling a Smart Contract
--------------------------

The Smart Contract object is a meta-class, so many of the functions in
it are not defined until it is instantiated with an application binary
interface (ABI) which is usually generated by a compiler, such as
Solidity. Therefore, we will use **solc-js** library -- JavaScript
bindings for the Solidity compiler.

To start with, **create** a new project at an appropriate place. In the
directory, **open** a terminal and initialize **package.json** file:

  -------------
  npm init -y
  -------------

After that, install **solc-js**:

  ---------------------------
  npm install ----save solc
  ---------------------------

Because we will read a smart contract from a file, we will need a
file-system library:

  -------------------------------
  npm install ----save fs-extra
  -------------------------------

Last but not least, **ethers.js**:

  -----------------------------
  npm install ----save ethers
  -----------------------------

After we have installed our dependencies, create a JavaScript file and
require them:

![](/assets/exercises-smart-contracts-ethers.js-01.png)

**Provider** abstracts a connection to the Ethereum blockchain for
issuing queries and sending state changing transactions. It is simply a
connection to the network. For the purposes of this exercise, we will
use the **Ropsten**.

Now, we will create a simple smart contract, which will store a string
array of facts in the blockchain. **Only** the **owner** of the contract
can **add** facts, but anyone can get how many **facts** are there and
get a fact by **index**.

![](/assets/exercises-smart-contracts-ethers.js-012.png)

Now that we have written the smart contract, we will create a function
in our JavaScript file, which reads a file and returns its content:

![](/assets/exercises-smart-contracts-ethers.js-017.png)

Let's compile the file now. We will create a function called
**compileContract**, which takes the name of the file and name of the
contract and returns an output of the compiled contract:

![](/assets/exercises-smart-contracts-ethers.js-019.png)

Deploy a Smart Contract
-----------------------

Now that we have compiled our Smart Contract for facts, it is time to
**deploy** it on the Ropsten Testnet. For the example of the exercise,
we will take one private key from MetaMask and use it as a signer for
the deployment transaction.

![](/assets/exercises-smart-contracts-ethers.js-020.png)

If you do not have ETHt, use the **MetaMask** faucet:
<https://faucet.metamask.io/>

![](/assets/exercises-smart-contracts-ethers.js-023.png)

First, we will create a **deployContract** function, which takes a
Private Key, contract filename and the contract's name.

To deploy a contract to the Ethereum Network, we must have its bytecode
and its application binary interface (ABI), usually generated from the
Solidity compile. Then, we will use **Contract.getDeployTransaction
(bytecode, interface ...)**, which generates the transaction needed to
deploy the contract specified by the bytecode and interface. Any
additional parameters the constructor take can be passed in (for
example: gas limit, gas price, etc.).

Then, through the wallet, we will **send** the transaction and as a
callback receive the **transaction**:

![](/assets/exercises-smart-contracts-ethers.js-03.png)

As we can see, in this format, we receive hash of the transaction, the
sender, the data, but on which address is the contract deployed?
Therefore, we will use an **ethers** **utility** **function**, which by
a given transaction calculates the address of the deployed contract.
Let's modify the **deployContract** method.

![](/assets/exercises-smart-contracts-ethers.js-05.png)

In addition, you can wait for the transaction to be mined with
**Provider.waitForTransaction (txHash)**, which returns an object
storing the contract's address. Keep in mind you will have to wait some
seconds until the transaction is mined.

![](/assets/exercises-smart-contracts-ethers.js-07.png)

Playing with the Smart Contract
-------------------------------

Now that the Smart Contract is deployed, we will connect to it using
**ethers** to **add** facts. In order to do this, we will use
**ethers.Contract (addressOrName, abi, providerOrSigner)** -- connects
to the contract **address** defined by the **ABI**, and the
**providerOrSigner** may be any instance of **Wallet**, **Provider** or
**Custom Signer**. For the purposes of this exercise, we will use a
Wallet instance.

Create a method called **addFact**, which takes the Contract Address, an
ABI of the contract, a Private Key for the wallet and the fact. The
method will return a callback of the created transaction.

![](/assets/exercises-smart-contracts-ethers.js-010.png)

What will happen if **someone**, **different** from contract owner,
tries to add a fact to the contract?

![](/assets/exercises-smart-contracts-ethers.js-011.png)

Now, let's create a method, which calls the contract's function
**getFact** (uint256 index). Keep in mind that when you want to **GET**
something from a contract, you **do not need** a wallet! Therefore, we
will just use the **provider**:

![](/assets/exercises-smart-contracts-ethers.js-014.png)

Last but not least, a function calling the **count ()** of the contract,
which returns the count of the facts in the contract:

![](/assets/exercises-smart-contracts-ethers.js-016.png)

What to Submit?
===============

Create a **zip file** (e.g.
**username-playing-smart-contracts-ethers-js.zip**) holding the
JavaScript file with the methods, a snapshot of the Ropsten Etherscan
contract address and its transactions.

Submit your **zip** file as **homework** at the course Website.
